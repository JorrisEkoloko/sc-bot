{
  "enabled": true,
  "name": "Control Flow Conflict & Shadowing Detector",
  "description": "Automatically detects conflicting control flow patterns where outer logic prevents inner logic from executing, including exception handlers, return statements, context managers, decorators, and callback chains that shadow or block each other.",
  "version": "1",
  "when": {
    "type": "userTriggered"
  },
  "then": {
    "type": "askAgent",
    "prompt": "Analyze the Python file for control flow conflicts and shadowing patterns:\n\n1. **Nested Handler Shadowing**: Detect when outer handlers prevent inner handlers from executing (exception handlers at multiple levels, signal handlers + exception handlers, event handlers that stop propagation, middleware/decorators that intercept before inner logic)\n\n2. **Early Exit Prevention**: Detect when early exits prevent cleanup or important logic (return statements before cleanup code, break/continue preventing finally blocks, exit/sys.exit() before context manager cleanup, exceptions raised before resource release, early returns in functions with cleanup responsibilities)\n\n3. **Context Manager Interference**: Detect when logic interferes with context manager lifecycle (exception handlers around with statements that prevent __exit__, return statements inside with blocks before cleanup, exceptions raised that bypass context manager cleanup, nested context managers where outer prevents inner cleanup)\n\n4. **Callback Chain Interruption**: Detect when callbacks/hooks prevent subsequent callbacks from executing (event listeners that stop propagation, middleware that doesn't call next(), decorators that return without calling wrapped function, hook chains where one hook prevents others, promise chains with missing .then() or .catch())\n\n5. **Resource Lifecycle Conflict**: Detect when resource management logic conflicts (multiple close() calls on same resource, cleanup in both exception handler and finally block, shutdown called from multiple signal handlers, resource freed in multiple code paths without guards, duplicate initialization without checking state)\n\n6. **State Machine Bypass**: Detect when code bypasses required state transitions (setting state directly instead of through transition methods, skipping required initialization steps, bypassing validation in state changes, direct attribute access instead of property setters, jumping states without cleanup of previous state)\n\n7. **Async/Sync Boundary Conflicts**: Detect when async and sync code interfere (calling async function without await, blocking sync call inside async function, event loop conflicts, sync exception handler around async code, async cleanup called from sync context)\n\n8. **Decorator/Wrapper Shadowing**: Detect when decorators prevent wrapped function behavior (decorator returns without calling wrapped function, multiple decorators where outer prevents inner, decorator catches exceptions from wrapped function, decorator modifies return value incorrectly, decorator changes function signature incompatibly)\n\n9. **Loop/Iterator Lifecycle Conflicts**: Detect when loops or iterators are prematurely terminated or shadowed (reassigning iterator variable inside loop, breaking out of generator before cleanup yield, using return in generator causing silent StopIteration, shadowing iterator variables in nested loops, overriding loop variables in closures)\n\n10.**Concurrency/Threading Interference**: Detect control flow and synchronization issues with concurrency primitives (lock acquired without guaranteed release, double lock/unlock, event or condition reset mid-wait, shared state mutated without synchronization, ordering conflicts causing race conditions)\n\n11.**Generator/Coroutine Cleanup Shadowing**: Detect skipped cleanup or teardown logic in async/sync generators (missing yield from or await, GeneratorExit ignored in cleanup, unhandled exceptions in finally, incomplete async generator closure leaving open handles)\n\n12.**Control Flow via Dynamic Features**: Detect dynamic shadowing that bypasses static control flow (monkey-patching core functions like open/print/exit, overriding builtins, rebinding function names to unrelated objects, using exec/eval to alter flow at runtime)\n\nFor each detected issue, provide:\n- **Pattern Type**: Which conflict pattern was detected\n- **Location**: File path, line numbers, and function/class context\n- **Description**: Clear explanation of the conflict\n- **Impact**: What execution is being prevented or shadowed\n- **Recommendation**: How to fix the conflict\n\nFocus on actual conflicts that would prevent correct execution, not theoretical issues. Prioritize issues by severity (blocking bugs > potential issues > style concerns)."
  }
}