"""
Symbol Mapper Utility

This utility helps resolve symbol discrepancies across different APIs.
It uses the symbol_mapping.json file generated by build_symbol_mapping.py

Example Usage:
    mapper = SymbolMapper()
    
    # Get the correct symbol for CoinMarketCap
    cmc_symbol = mapper.get_symbol_for_api(
        address="0x562e362876c8aee4744fc2c6aac8394c312d215d",
        api="coinmarketcap"
    )
    # Returns: "OPTI"
    
    # Get the correct symbol for DexScreener
    dex_symbol = mapper.get_symbol_for_api(
        address="0x562e362876c8aee4744fc2c6aac8394c312d215d",
        api="dexscreener"
    )
    # Returns: "OPTIMUS"
"""

import json
import os
from typing import Optional, Dict
from pathlib import Path


class SymbolMapper:
    def __init__(self, mapping_file: Optional[str] = None):
        """
        Initialize the symbol mapper
        
        Args:
            mapping_file: Path to symbol_mapping.json. If None, uses default location.
        """
        if mapping_file is None:
            # Default to data/symbol_mapping.json
            base_dir = Path(__file__).parent.parent
            mapping_file = base_dir / "data" / "symbol_mapping.json"
        
        self.mapping_file = mapping_file
        self.symbol_map = self._load_mapping()
    
    def _load_mapping(self) -> Dict:
        """Load the symbol mapping from JSON file"""
        try:
            if os.path.exists(self.mapping_file):
                with open(self.mapping_file, 'r') as f:
                    return json.load(f)
            else:
                print(f"Warning: Symbol mapping file not found at {self.mapping_file}")
                print("Run build_symbol_mapping.py to generate it.")
                return {}
        except Exception as e:
            print(f"Error loading symbol mapping: {e}")
            return {}
    
    def normalize_address(self, address: str, chain: str = "ethereum") -> str:
        """Normalize address for lookup"""
        if not address:
            return None
        # Solana addresses are case-sensitive, Ethereum are not
        if chain.lower() == "solana":
            return address
        return address.lower()
    
    def get_symbol_for_api(
        self, 
        address: str, 
        api: str, 
        chain: str = "ethereum",
        fallback_symbol: Optional[str] = None
    ) -> str:
        """
        Get the correct symbol for a specific API
        
        Args:
            address: Token contract address
            api: API name (coinmarketcap, dexscreener, coingecko, cryptocompare, etc.)
            chain: Blockchain (ethereum, solana, base, etc.)
            fallback_symbol: Symbol to return if not found in mapping
        
        Returns:
            The correct symbol for the specified API, or fallback_symbol if not found
        """
        normalized_address = self.normalize_address(address, chain)
        
        if not normalized_address or normalized_address not in self.symbol_map:
            return fallback_symbol
        
        token_data = self.symbol_map[normalized_address]
        symbols = token_data.get("symbols", {})
        
        # Try to get the symbol for the specific API
        api_lower = api.lower()
        if api_lower in symbols:
            return symbols[api_lower]
        
        # Fallback to primary symbol
        primary = token_data.get("primary_symbol")
        if primary:
            return primary
        
        return fallback_symbol
    
    def get_all_symbols(self, address: str, chain: str = "ethereum") -> Dict[str, str]:
        """
        Get all known symbols for a token across all APIs
        
        Args:
            address: Token contract address
            chain: Blockchain
        
        Returns:
            Dictionary mapping API names to symbols
        """
        normalized_address = self.normalize_address(address, chain)
        
        if not normalized_address or normalized_address not in self.symbol_map:
            return {}
        
        return self.symbol_map[normalized_address].get("symbols", {})
    
    def get_primary_symbol(self, address: str, chain: str = "ethereum") -> Optional[str]:
        """
        Get the primary (most common) symbol for a token
        
        Args:
            address: Token contract address
            chain: Blockchain
        
        Returns:
            Primary symbol or None
        """
        normalized_address = self.normalize_address(address, chain)
        
        if not normalized_address or normalized_address not in self.symbol_map:
            return None
        
        return self.symbol_map[normalized_address].get("primary_symbol")
    
    def get_token_names(self, address: str, chain: str = "ethereum") -> list:
        """
        Get all known names for a token
        
        Args:
            address: Token contract address
            chain: Blockchain
        
        Returns:
            List of token names
        """
        normalized_address = self.normalize_address(address, chain)
        
        if not normalized_address or normalized_address not in self.symbol_map:
            return []
        
        return self.symbol_map[normalized_address].get("names", [])
    
    def has_symbol_discrepancy(self, address: str, chain: str = "ethereum") -> bool:
        """
        Check if a token has different symbols across APIs
        
        Args:
            address: Token contract address
            chain: Blockchain
        
        Returns:
            True if symbols differ across APIs
        """
        symbols = self.get_all_symbols(address, chain)
        unique_symbols = set(symbols.values())
        return len(unique_symbols) > 1


# Example usage
if __name__ == "__main__":
    mapper = SymbolMapper()
    
    # Test with OPTIMUS AI
    optimus_address = "0x562e362876c8aee4744fc2c6aac8394c312d215d"
    
    print("OPTIMUS AI Symbol Mapping:")
    print(f"Address: {optimus_address}")
    print(f"Primary Symbol: {mapper.get_primary_symbol(optimus_address)}")
    print(f"Names: {mapper.get_token_names(optimus_address)}")
    print(f"\nSymbols by API:")
    
    all_symbols = mapper.get_all_symbols(optimus_address)
    for api, symbol in all_symbols.items():
        print(f"  {api}: {symbol}")
    
    print(f"\nHas discrepancy: {mapper.has_symbol_discrepancy(optimus_address)}")
    
    # Test API-specific lookups
    print(f"\nAPI-Specific Lookups:")
    print(f"  CoinMarketCap: {mapper.get_symbol_for_api(optimus_address, 'coinmarketcap')}")
    print(f"  DexScreener: {mapper.get_symbol_for_api(optimus_address, 'dexscreener')}")
    print(f"  CoinGecko: {mapper.get_symbol_for_api(optimus_address, 'coingecko')}")
